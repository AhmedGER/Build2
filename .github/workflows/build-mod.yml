# .github/workflows/build-mod.yml
name: Build Bridging Mod (Stable & Accurate)

on:
  workflow_dispatch:

jobs:
  setup-and-build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Set up JDK 8
      uses: actions/setup-java@v3
      with:
        java-version: '8'
        distribution: 'temurin'
    
    - name: Setup Gradle
      uses: gradle/gradle-build-action@v2
      with:
        gradle-version: 6.9
    
    - name: Clean everything
      run: |
        rm -rf src/ build/ .gradle/ gradle/ *.gradle *.properties gradlew* .gitignore
        find . -name "*.java" -delete
        find . -name "*.json" -delete
    
    - name: Create directories
      run: |
        mkdir -p src/main/java/com/example/bridging/mixin
        mkdir -p src/main/resources
    
    - name: Write BridgingMod.java
      shell: bash
      run: |
        cat << 'EOF' > src/main/java/com/example/bridging/BridgingMod.java
        package com.example.bridging;
        import net.fabricmc.api.ClientModInitializer;
        import net.minecraft.util.math.BlockPos;
        public class BridgingMod implements ClientModInitializer {
            public static final String MOD_ID = "bridging";
            public static int tickDelay = 0;
            public static BlockPos lastPlacedBlock = null;
            public static int confirmationTicks = 0;
            @Override
            public void onInitializeClient() {
                System.out.println("[Stable Bridging] Place first block manually, then hold RIGHT CLICK!");
            }
        }
        EOF
    
    - name: Write ClientPlayerEntityMixin.java
      shell: bash
      run: |
        cat << 'EOF' > src/main/java/com/example/bridging/mixin/ClientPlayerEntityMixin.java
        package com.example.bridging.mixin;
        import com.example.bridging.BridgingMod;
        import net.minecraft.block.BlockState;
        import net.minecraft.client.MinecraftClient;
        import net.minecraft.client.network.ClientPlayerEntity;
        import net.minecraft.item.BlockItem;
        import net.minecraft.item.ItemStack;
        import net.minecraft.util.ActionResult;
        import net.minecraft.util.Hand;
        import net.minecraft.util.hit.BlockHitResult;
        import net.minecraft.util.math.BlockPos;
        import net.minecraft.util.math.Direction;
        import net.minecraft.util.math.Vec3d;
        import org.spongepowered.asm.mixin.Mixin;
        import org.spongepowered.asm.mixin.injection.At;
        import org.spongepowered.asm.mixin.injection.Inject;
        import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
        @Mixin(ClientPlayerEntity.class)
        public class ClientPlayerEntityMixin {
            @Inject(method = "tick", at = @At("HEAD"))
            private void onTick(CallbackInfo ci) {
                ClientPlayerEntity player = (ClientPlayerEntity)(Object)this;
                MinecraftClient client = MinecraftClient.getInstance();
                
                if (client.world == null || client.options == null) return;
                
                // إذا اللاعب مش ضاغط على زر الاستخدام
                if (!client.options.keyUse.isPressed()) {
                    BridgingMod.tickDelay = 0;
                    BridgingMod.confirmationTicks = 0;
                    return;
                }
                
                // التحقق من أن اللاعب ماسك بلوك
                ItemStack mainHand = player.getMainHandStack();
                if (!(mainHand.getItem() instanceof BlockItem)) {
                    BridgingMod.lastPlacedBlock = null;
                    BridgingMod.confirmationTicks = 0;
                    return;
                }
                
                // انتظر الـ delay
                if (BridgingMod.tickDelay > 0) {
                    BridgingMod.tickDelay--;
                    return;
                }
                
                // موقع البلوك المستهدف (تحت اللاعب)
                BlockPos targetPos = player.getBlockPos().down();
                BlockState targetState = client.world.getBlockState(targetPos);
                
                // لو في بلوك موجود تحتك بالفعل
                if (!targetState.isAir()) {
                    BridgingMod.lastPlacedBlock = targetPos;
                    BridgingMod.confirmationTicks = 0;
                    return;
                }
                
                // ★ التحقق من آخر بلوك: لو موجود، استنى 2 ticks للتأكد إنه stable
                if (BridgingMod.lastPlacedBlock != null) {
                    BlockState lastBlockState = client.world.getBlockState(BridgingMod.lastPlacedBlock);
                    if (lastBlockState.isAir()) {
                        // البلوك اختفى! السيرفر رفضه
                        BridgingMod.lastPlacedBlock = null;
                        BridgingMod.confirmationTicks = 0;
                        // استنى وقت أطول قبل ما تحاول تاني
                        BridgingMod.tickDelay = 4;
                        return;
                    }
                    
                    // استنى شوية للتأكد إن البلوك stable
                    if (BridgingMod.confirmationTicks < 2) {
                        BridgingMod.confirmationTicks++;
                        return;
                    }
                }
                
                // ★ لاقي أقرب بلوك صلب مجاور
                BlockPos adjacentBlock = findBestAdjacentBlock(client, targetPos, player);
                
                if (adjacentBlock == null) {
                    // مفيش بلوك صلب قريب
                    BridgingMod.lastPlacedBlock = null;
                    return;
                }
                
                // ★ تحديد الوجه الصحيح بناءً على موقع اللاعب
                Direction placementFace = calculateBestFace(adjacentBlock, targetPos, player.getPos());
                
                if (placementFace == null) {
                    return;
                }
                
                // حساب نقطة الضرب على وجه البلوك (في النص بالضبط)
                Vec3d hitVec = Vec3d.ofCenter(adjacentBlock).add(
                    placementFace.getOffsetX() * 0.5,
                    placementFace.getOffsetY() * 0.5,
                    placementFace.getOffsetZ() * 0.5
                );
                
                // التحقق من المسافة - أقصر مسافة للدقة
                double distance = player.getPos().distanceTo(hitVec);
                if (distance > 4.5) return;
                
                // إنشاء BlockHitResult بشكل دقيق
                BlockHitResult hitResult = new BlockHitResult(
                    hitVec, 
                    placementFace, 
                    adjacentBlock, 
                    false
                );
                
                if (client.interactionManager != null) {
                    // حاول تحط البلوك
                    ActionResult result = client.interactionManager.interactBlock(
                        player, 
                        client.world, 
                        Hand.MAIN_HAND, 
                        hitResult
                    );
                    
                    if (result.isAccepted()) {
                        // عمل hand animation
                        player.swingHand(Hand.MAIN_HAND);
                        
                        // حفظ آخر بلوك اتحط
                        BridgingMod.lastPlacedBlock = targetPos;
                        BridgingMod.confirmationTicks = 0;
                        
                        // ★ Delay أطول للاستقرار والدقة
                        // لو على الأرض: 3-4 ticks
                        // لو في الهوا: 2-3 ticks
                        int baseDelay = player.isOnGround() ? 3 : 2;
                        BridgingMod.tickDelay = baseDelay + (int)(Math.random() * 2);
                    } else {
                        // البلوك ما اتحطش - استنى أكتر
                        BridgingMod.tickDelay = 5;
                    }
                }
            }
            
            /**
             * يبحث عن أفضل بلوك صلب مجاور بناءً على موقع اللاعب
             */
            private BlockPos findBestAdjacentBlock(MinecraftClient client, BlockPos target, ClientPlayerEntity player) {
                Vec3d playerPos = player.getPos();
                
                // حدد الاتجاه الأفقي الأساسي بناءً على اتجاه اللاعب
                Direction playerFacing = player.getHorizontalFacing();
                Direction behind = playerFacing.getOpposite();
                
                // ترتيب الأولويات: خلف اللاعب > تحت > الجوانب > فوق
                Direction[] priorityDirections = {
                    behind,              // الأولوية الأولى: خلف اللاعب
                    Direction.DOWN,      // تحت
                    behind.rotateYClockwise(),     // يمين
                    behind.rotateYCounterclockwise(), // شمال
                    playerFacing,        // أمام (أقل أولوية)
                    Direction.UP         // فوق (آخر خيار)
                };
                
                // جرب كل اتجاه بالترتيب
                for (Direction dir : priorityDirections) {
                    BlockPos checkPos = target.offset(dir);
                    BlockState state = client.world.getBlockState(checkPos);
                    
                    // تحقق من أن البلوك صلب
                    if (!state.isAir() && state.isSolidBlock(client.world, checkPos)) {
                        // تحقق من المسافة
                        double dist = playerPos.squaredDistanceTo(Vec3d.ofCenter(checkPos));
                        if (dist < 25.0) { // أقل من 5 blocks
                            return checkPos;
                        }
                    }
                }
                
                // إذا ما لقيناش، استخدم آخر بلوك اتحط
                if (BridgingMod.lastPlacedBlock != null) {
                    BlockState lastState = client.world.getBlockState(BridgingMod.lastPlacedBlock);
                    if (!lastState.isAir() && lastState.isSolidBlock(client.world, BridgingMod.lastPlacedBlock)) {
                        return BridgingMod.lastPlacedBlock;
                    }
                }
                
                return null;
            }
            
            /**
             * يحسب أفضل وجه للبلوك بناءً على موقع اللاعب والهدف
             */
            private Direction calculateBestFace(BlockPos adjacent, BlockPos target, Vec3d playerPos) {
                // احسب الاتجاه من البلوك المجاور للهدف
                int dx = target.getX() - adjacent.getX();
                int dy = target.getY() - adjacent.getY();
                int dz = target.getZ() - adjacent.getZ();
                
                // أولاً: حدد الوجه بناءً على الفرق في الموقع
                Direction face = null;
                
                if (Math.abs(dx) > 0) {
                    face = dx > 0 ? Direction.EAST : Direction.WEST;
                } else if (Math.abs(dz) > 0) {
                    face = dz > 0 ? Direction.SOUTH : Direction.NORTH;
                } else if (dy > 0) {
                    face = Direction.UP;
                } else if (dy < 0) {
                    face = Direction.DOWN;
                }
                
                // تحقق من أن الوجه منطقي
                if (face != null) {
                    // تأكد إن الوجه بيواجه الهدف الصحيح
                    BlockPos testPos = adjacent.offset(face);
                    if (testPos.equals(target)) {
                        return face;
                    }
                }
                
                return face;
            }
        }
        EOF
    
    - name: Write fabric.mod.json
      shell: bash
      run: |
        cat << 'EOF' > src/main/resources/fabric.mod.json
        {
          "schemaVersion": 1,
          "id": "bridging",
          "version": "4.0.0",
          "name": "Stable Bridging Helper",
          "description": "Accurate and stable bridging with server validation",
          "authors": ["AutoBuilder"],
          "license": "MIT",
          "environment": "client",
          "entrypoints": {
            "client": ["com.example.bridging.BridgingMod"]
          },
          "mixins": ["bridging.mixins.json"],
          "depends": {
            "fabricloader": ">=0.11.0",
            "fabric": "*",
            "minecraft": "1.16.5"
          }
        }
        EOF
    
    - name: Write bridging.mixins.json
      shell: bash
      run: |
        cat << 'EOF' > src/main/resources/bridging.mixins.json
        {
          "required": true,
          "minVersion": "0.8",
          "package": "com.example.bridging.mixin",
          "compatibilityLevel": "JAVA_8",
          "client": ["ClientPlayerEntityMixin"],
          "injectors": {"defaultRequire": 1}
        }
        EOF
    
    - name: Write build.gradle
      shell: bash
      run: |
        cat << 'EOF' > build.gradle
        plugins {
            id 'fabric-loom' version '0.7-SNAPSHOT'
            id 'maven-publish'
        }
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
        archivesBaseName = "stable-bridging"
        version = "4.0.0"
        group = "com.example"
        repositories {
            maven { url 'https://maven.fabricmc.net/' }
            maven {
                url 'https://www.cursemaven.com'
                content { includeGroup "curse.maven" }
            }
        }
        dependencies {
            minecraft "com.mojang:minecraft:1.16.5"
            mappings "net.fabricmc:yarn:1.16.5+build.10:v2"
            modImplementation "net.fabricmc:fabric-loader:0.11.3"
            modImplementation "curse.maven:fabric-api-306612:3516413"
        }
        processResources {
            inputs.property "version", project.version
            filesMatching("fabric.mod.json") { expand "version": project.version }
        }
        tasks.withType(JavaCompile).configureEach {
            it.options.encoding = "UTF-8"
        }
        java { withSourcesJar() }
        jar {
            from("LICENSE") { rename { "${it}_${project.archivesBaseName}"} }
        }
        EOF
    
    - name: Write gradle.properties
      run: echo 'org.gradle.jvmargs=-Xmx2G' > gradle.properties
    
    - name: Write settings.gradle
      shell: bash
      run: |
        cat << 'EOF' > settings.gradle
        pluginManagement {
            repositories {
                maven { name = 'Fabric'; url = 'https://maven.fabricmc.net/' }
                gradlePluginPortal()
            }
        }
        rootProject.name = 'stable-bridging'
        EOF
    
    - name: Create Gradle Wrapper
      run: gradle wrapper --gradle-version 6.9
    
    - name: Grant execute permission
      run: chmod +x gradlew
    
    - name: Verify all files
      run: |
        echo "=== Source files ==="
        find src -type f -exec echo {} \; -exec cat {} \;
        echo "=== Config files ==="
        cat build.gradle
        cat settings.gradle
    
    - name: Build mod
      run: ./gradlew clean build --no-daemon --stacktrace
    
    - name: List build output
      run: ls -lah build/libs/
    
    - name: Upload Mod JAR
      uses: actions/upload-artifact@v4
      with:
        name: stable-bridging-v4.0.0-accurate
        path: build/libs/*.jar
